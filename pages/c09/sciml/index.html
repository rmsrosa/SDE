<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="" />
  <meta name="author" content="and contributors" />
   <title>O ambiente SciML da linguagem Julia</title>  
  <link rel="shortcut icon" type="image/png" href="/notas_sde/assets/images/favicon_randgon.png"/>
  <link rel="stylesheet" href="/notas_sde/css/base.css"/>
  
  <script src="/notas_sde/libs/mousetrap/mousetrap.min.js"></script>

  
    <link rel="stylesheet" href="/notas_sde/libs/highlight/github.min.css">
    <script src="/notas_sde/libs/highlight/highlight.pack.js"></script>
    <script src="/notas_sde/libs/highlight/julia.min.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', (event) => {
        document.querySelectorAll('pre').forEach((el) => {
          hljs.highlightElement(el);
        });
      });
    </script>
  

  
    <link rel="stylesheet" href="/notas_sde/libs/katex/katex.min.css">
  
</head>

<body>

  <div class="books-container">

  <aside class="books-menu">
  <input type="checkbox" id="menu">
  <label for="menu">☰</label>

  <div class="books-title">
    <a href="/notas_sde/">Equações Diferenciais Estocásticas e Aleatórias</a>
  </div>

  <br />

  <div class="books-subtitle">
    Aspectos Teóricos e Numéricos
  </div>

  <br />

  <div class="books-author">
    <a href="https://rmsrosa.github.io">Ricardo M. S. Rosa</a>
  </div>

  <div class="books-menu-content">
    <div class="menu-level-1">
    <li>1. Introdução</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c01/apresentacao">1.1. Apresentação</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c01/aspectos_iniciais">1.2. Equações diferenciais aleatórias e estocásticas</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c01/aspectos_numericos">1.3. Aspectos numéricos</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/literated/c01/simulacoes_numericas">1.4. Simulações numéricas de modelos de crescimento natural</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c01/movimento_Browniano">1.5. Movimento Browniano</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c01/passeioaleatorio_movBrowniano">1.6. Do passeio aleatório ao movimento Browniano</a></li>
    </div>
    <div class="menu-level-1">
    <li>2. Variáveis Aleatórias</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c02/definicao_va">2.1. Conceitos essenciais</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c02/exemplos_va_discretas">2.2. Variáveis aleatórias discretas</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c02/exemplos_va_continuas">2.3. Variáveis aleatórias contínuas</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c02/media_momentos">2.4. Média, variância e outros momentos</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c02/prob_condicionada">2.5. Probabilidade condicionada</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c02/desigualdades">2.6. Desigualdades importantes</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c02/multi_va">2.7. Variáveis aleatórias multivariadas</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c02/transformacoes">2.8. Transformações de variáveis aleatórias</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c02/convergencias">2.9. Tipos de convergências</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c02/borel_cantelli">2.10. Lema de Borel-Cantelli</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c02/teorema_central">2.11. Teorema Central do Limite</a></li>
    </div>
    <div class="menu-level-1">
    <li>3. O método de Monte-Carlo</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c03/monte_carlo">3.1. O método de Monte-Carlo no estudo de variáveis aleatórias</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c03/histograma">3.2. Histograma - estimando a distribuição de probabilidades</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c03/gerando_num_aleatorios">3.3. Gerando números aleatórios no computador</a></li>
    </div>
    <div class="menu-level-1">
    <li>4. Processos Estocásticos</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c04/definicao_pe">4.1. Conceitos essenciais</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c04/processos_discretos">4.2. Processos discretos</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c04/processos_continuos">4.3. Processos contínuos</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c04/tipos_processos">4.4. Tipos de processos</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c04/filtracao">4.5. Filtração</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c04/cadeias_markov">4.6. Processos de Markov</a></li>
    </div>
    <div class="menu-level-1">
    <li>5. Processos de Wiener</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c05/definicao_processo_wiener">5.1. Definição</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c05/existencia_processo_wiener">5.2. Existência de processos de Wiener</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c05/simetrias_wiener">5.3. Simetrias de processos de Wiener</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c05/naodiferenciabilidade_wiener">5.4. Não diferenciabilidade quase sempre dos caminhos amostrais</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c05/variacao_ilimitada_wiener">5.5. Variação ilimitada quase sempre dos caminhos amostrais</a></li>
    </div>
    <div class="menu-level-1">
    <li>6. Integração estocástica</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c06/integral_riemann">6.1. Integrais de Riemann</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c06/integral_riemannstieltjes">6.2. Integrais de Riemann-Stieltjes</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c06/integral_dualidade">6.3. Integrais via dualidade</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c06/riemann_wiener">6.4. Limites de somatórios à la Riemann-Stieltjes</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c06/integral_ito">6.5. Integral de Itô</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c06/integral_ito_propriedades">6.6. Propriedades da integral de Itô</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c06/formula_ito">6.7. Fórmula de Itô</a></li>
    </div>
    <div class="menu-level-1">
    <li>7. Equações diferenciais aleatórias</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c07/existence_solutions_rde">7.1. Existência e unicidade de soluções</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c07/basic_examples_rde">7.2. Exemplos básicos</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c07/logistic_rde">7.3. Equação logística aleatória</a></li>
    </div>
    <div class="menu-level-1">
    <li>8. Equações diferenciais estocásticas</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c08/setting">8.1. Interpretação da equação</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c08/existence_solutions_sde_particulares">8.2. Existência de soluções em casos particulares</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c08/existence_solutions_sde">8.3. Existência de soluções no caso geral</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c08/unicidade_sol_sde">8.4. Unicidade de soluções</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c08/continuidade_caminhos">8.5. Continuidade dos caminhos amostrais</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c08/linear_sde">8.6. Resolução de equações lineares</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c08/geometric_brownian">8.7. Movimento Browniano geométrico e o preço de ações</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c08/brownian_bridge">8.8. Ponte Browniana</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c08/ornstein_uhlenbeck">8.9. O processo de Ornstein-Uhlenbeck e a equação de Langevin</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c08/feynmann_kac">8.10. Fórmula de Feynman-Kac</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c08/relacoes_rode_sde">8.11. Relações entre equações estocásticas e equações aleatórias</a></li>
    </div>
    <div class="menu-level-1">
    <li>9. Métodos numéricos</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c09/tx_convergencia">9.1. Convergências forte e fraca</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c09/simulacoes_wiener">9.2. Simulações de processos de Wiener e browniano geométrico</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c09/convergencia_euler_maruyama">9.3. Convergência do método de Euler-Maruyama</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c09/simulacoes_convergencia_em">9.4. Simulações ilustrando ordem de  convergência do método de Euler-Maruyama</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c09/heun">9.5. Método de Heun</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c09/milstein">9.6. O método de Milstein</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c09/simulacoes_milstein">9.7. Simulações Milstein</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c09/sciml">9.8. O ambiente SciML da linguagem Julia</a></li>
    </div>
    <div class="menu-level-1">
    <li>10. Evolução da função densidade de probabilidade</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/c10/deterministic">10.1. Evolução no caso de equações determinísticas</a></li>
    </div>
    <div class="menu-level-2">
    <li>10.2. Evolução no caso de equações aleatórias</li>
    </div>
    <div class="menu-level-2">
    <li>10.3. Kolmogorov backward equation</li>
    </div>
    <div class="menu-level-2">
    <li>10.4. Kolmogorov forward equation</li>
    </div>
    <div class="menu-level-2">
    <li>10.5. Evolução no caso de equações estocásticas</li>
    </div>
    <div class="menu-level-2">
    <li>10.6. Soluções estacionárias</li>
    </div>
    <div class="menu-level-2">
    <li>10.7. Métodos numéricos</li>
    </div>
    <div class="menu-level-1">
    <li>11. Sistemas de equações aleatórias</li>
    </div>
    <div class="menu-level-1">
    <li>12. Sistemas de equações estocásticas</li>
    </div>
    <div class="menu-level-1">
    <li>Apêndice</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/appendix/teo_fund_kolmogorov">Teorema Fundamental de Kolmogorov</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/notas_sde/pages/appendix/teo_extension_kolmogorov">Teorema de Extensão de Kolmogorov</a></li>
    </div>
    <div class="menu-level-1">
    <li><a href="/notas_sde/pages/references">References</a></li>
    </div>
<div>


  
    <a href="https://github.com/rmsrosa/notas_sde"><img src="/notas_sde/assets/images/GitHub-Mark-32px.png" alt="GitHub repo" width="18" style="margin:5px 5px" align="left"></a>

  

</aside>


  <div class="books-content">

    
      <div class="navbar">
    <p id="nav">
<span id="nav-prev" style="float: left;">
<a class="menu-level-1" href="/notas_sde/pages/c09/simulacoes_milstein">9.7. Simulações Milstein <kbd>←</kbd></a>
</span>
<span id="nav-next" style="float: right;">
    <a class="menu-level-1" href="/notas_sde/pages/c10/deterministic"><kbd>→</kbd> 10.1. Evolução no caso de equações determinísticas</a>
</span>
    </p>
</div>
</br></br>

    

    
      
    
<h1 id="get_title"><a href="#get_title" class="header-anchor">9.8. O ambiente SciML da linguagem Julia</a></h1>
<p>Estivemos, até agora, implementando diretamente os métodos numéricos, por motivos didáticos. Nas aplicações, porém, podemos utilizar pacotes numéricos que já têm esses e outros métodos implementados. Nos basta formular o problema de acordo com a interface de cada pacote &#40;chamada de <em>api</em>, acrônimo de <em>application programming interface</em>&#41;.</p>
<p>Nesse sentido, o ambiente <a href="https://docs.sciml.ai/dev/">SciML - The SciML Open Source Software Ecosystem</a> é um dos carros chefes da linguagem <a href="The SciML Open Source Software Ecosystem">Julia</a>, com uma ampla gama de métodos implementados e otimizados. Há não apenas métodos para aproximar os caminhos amostrais de soluções de equações estocásticas e aleatórias, mas também para serem usados em conjunto com métodos de determinação de parâmetros, quantificação de incertezas, redes neurais e modelagem simbólica.</p>
<p>Vamos ilustrar aqui como usar esse ambiente para resolver as equações tratadas até agora. Nos capítulos seguintes, exploraremos esse ambiente na resolução de problemas mais complexos, envolvendo sistemas de equações.</p>
<p>O ambiente contém pacotes para a resolução de <a href="https://docs.sciml.ai/dev/modules/DiffEqDocs/types/sde_types/">equações diferenciais estocásticas</a>, <a href="https://docs.sciml.ai/dev/modules/DiffEqDocs/types/sdae_types/">equações estocástico-algébricas</a>, <a href="https://docs.sciml.ai/dev/modules/DiffEqDocs/types/sdde_types/">equações estocásticas com retardamento/atraso</a> e <a href="https://docs.sciml.ai/dev/modules/DiffEqDocs/types/rode_types/">equações diferenciais aleatórias</a>, além de diversos métodos para equações determinísticas &#40;veja <a href="https://docs.sciml.ai/dev/#Domains-of-SciML">Domains of SciML</a>&#41;.</p>
<p>O ambiente <a href="https://docs.sciml.ai/dev/">SciML - The SciML Open Source Software Ecosystem</a> é uma <a href="https://github.com/SciML">organização SciML no github</a> e mantém, mais precisamente, uma <a href="https://github.com/orgs/SciML/repositories">longa lista de repositórios</a> com pacotes Julia. É possivel instalar o pacote <a href="https://github.com/SciML/DifferentialEquations.jl">SciML/DifferentialEquations.jl</a> que é um <em>wrapper</em> para quase todos os pacotes. Isso facilita em um certo sentido, mas por outro lado torna a instalação mais lenta e pesada. Uma alternativa é instalar apenas os pacotes necessários para o problema em questão. Para os nossos objetivos, vamos instalar apenas os pacotes <a href="https://github.com/SciML/OrdinaryDiffEq.jl/tree/master/src">SciML/OrdinaryDiffEq.jl</a>, que contém os métodos para a resolução de equações diferenciais ordinárias determinísticas, e <a href="https://github.com/SciML/StochasticDiffEq.jl">SciML/StochasticDiffEq.jl</a>, que contém os pacotes para a resolução de equações diferenciais aleatórias e estocásticas.</p>
<h2 id="resolvendo_equações_aleatórias_via_sciml"><a href="#resolvendo_equações_aleatórias_via_sciml" class="header-anchor">Resolvendo equações aleatórias via SciML</a></h2>
<p>Vamos ver como usar <a href="https://docs.sciml.ai/dev/modules/DiffEqDocs/types/rode_types/">a interface para equações aleatórias</a>, acessível pelo pacote <a href="https://github.com/SciML/StochasticDiffEq.jl">SciML/StochasticDiffEq.jl</a>. Além dele, usamos o pacote <a href="https://github.com/JuliaPlots/Plots.jl">JuliaPlots/Plots.jl</a>, com o tema <code>:ggplot2</code>, para os gráficos. Para utilizar esses pacotes, usamos as seguintes linhas de código.</p>
<pre><code class="language-julia">using StochasticDiffEq
using Plots
theme&#40;:ggplot2&#41;</code></pre>
<p>Para aprender a usar o pacote de equações estocásticas, é útil ver os exemplos em <a href="https://docs.sciml.ai/dev/modules/DiffEqDocs/tutorials/rode_example/">tutorial SciML - RODE</a>. A interface considera um <em>problema de valor inicial,</em> da forma</p>
\[
\frac{\mathrm{d}u}{\mathrm{d}t} = f(u, p, t, W(t)), \quad t_0 \leq t \leq T,
\]
<p>com uma condição inicial</p>
\[
u(t_0) = u_0.
\]
<p>O objetivo da interface é disponibilizar métodos para aproximar um <em>caminho amostral</em> dessa equação, de maneira que a condição inicial deve ser informada como sendo uma variável do tipo <code>Number</code> &#40;como <code>Float64</code>, <code>Float32</code>, <code>Int</code>, etc.&#41;, ou do tipo <code>AbstractArray&#123;&lt;:Number&#125;</code> &#40;no caso de sistemas de equações ou, até mesmo, de um conjunto amostral&#41;.</p>
<p>Além disso, devemos informar a função <code>f&#40;u, p, t, W&#41;</code>, onde <code>p</code> é um conjunto de parâmetros, <code>t</code> é a variável temporal, e <code>W</code> representa um processo estocástico.</p>
<p>O conjunto de parâmetros <code>p</code> pode ser dado de várias maneiras, como, por exemplo, um escalar, um vetor ou uma lista de números ou de outros tipos. A variável temporal <code>t</code> deve ser um número. E o processo <code>W</code> é um <em>ruído</em> conforme definido em <a href="https://noise.sciml.ai/stable/">ScimML/DiffEqNoiseProcess.jl</a>.</p>
<p>A solução numérica é obtida através de um <em>problema</em> montado via <code>RODEProblem&#40;&#41;</code>, que tem duas assinaturas:</p>
<ol>
<li><p><code>RODEProblem&#40;f::RODEFunction,u0,tspan,p&#61;NullParameters&#40;&#41;;noise&#61;WHITE_NOISE,rand_prototype&#61;nothing,callback&#61;nothing&#41;</code></p>
</li>
<li><p><code>RODEProblem&#123;isinplace&#125;&#40;f,u0,tspan,p&#61;NullParameters&#40;&#41;;noise&#61;WHITE_NOISE,rand_prototype&#61;nothing,callback&#61;nothing,mass_matrix&#61;I&#41;</code>.</p>
</li>
</ol>
<p>Na prática, a principal diferença é se o primeiro argumento é da forma <code>f&#40;u, t, p, W&#41;</code> ou da forma <code>f&#33;&#40;du, u, t, p, W&#41;</code>. Lembre-se que a exclamação ao final do nome da função é apenas uma convenção, para informar se a função altera um dos seus argumentos ou não. O que distingue as duas funções é que a primeira tem quatro argumentos e a segunda tem cinco argumentos. Ao definirmos um <code>RODEProblem&#40;f, u0, tspan, ...&#41;</code> ou um <code>RODEProblem&#40;f&#33;, u0, tspan, ...&#41;</code>, a interface irá escolher o método certo baseado na forma da função passada como primeiro argumento.</p>
<p>A primeira forma da função, <code>f&#40;u, p, t, W&#41;</code>, retorna um valor armazenado em uma nova variável <code>du</code> que é usado como sendo a derivada temporal de <code>u</code>. A segunda forma recebe uma variável <code>du</code> já alocada na memória e apenas atualiza o valor dessa variável com a derivada de <code>u</code>. O primeiro caso é apropriado para equações escalares, em que <code>u</code> e <code>du</code> são variáveis imutáveis &#40;e.g. <code>u::Float64</code> e <code>du::Float64</code>&#41;. O segundo caso é apropriado para sistemas de equações, onde <code>u</code> e <code>du</code> são vetores ou arrays &#40;e.g. <code>u::Vector&#123;Float64&#125;</code>&#41;, portanto mutáveis, sendo muito mais eficiente atualizar o valor de <code>du</code> do que criar um novo vetor a cada iteração, gerando novas alocações e um acúmulo desnecessário de recursos computacionais.</p>
<p>Uma vez montado um problema <code>prob &#61; RODEProblem&#40;f, u0, tspan, ...&#41;</code>, podemos resolvê-lo através da função <code>solve</code>. Se tivermos o pacote <a href="https://github.com/SciML/DifferentialEquations.jl">SciML/DifferentialEquations.jl</a> carregado, basta escrevermos <code>solve&#40;prob&#41;</code> que a interface escolhe um método numérico apropriado para resolver o problema. Mas, como dissemos acima, esse pacote é muito pesado, pois carrega dezenas de pacotes do ambiente SciML. Além disso, um objetivo principal aqui é didático. Assim, optamos por não carregar esse pacote e escolher explicitamente o método numérico.</p>
<p>No caso de equações estocásticas aleatórias, o único método disponível é o de Euler-Maruyama. Outros métodos podem ser acessados convertendo a equação aleatória em uma equação estocástica, visto que há uma ampla gama de métodos implementados para estas equações, mas para equações aleatórias, especificamente, temos apenas o Euler-Maruyama. Para revolvermos via Euler-Maruyama, passamos o argumento <code>RandomEM&#40;&#41;</code>, que identifica esse método. Este é um método de passo fixo e devemos, também, passar o tamanho do passo. Assim, podemos resolver o problema via <code>sol &#61; solve&#40;prob, RandomEM&#40;&#41;, dt&#61;1/100&#41;</code>.</p>
<p>Uma vez resolvido o problema, podemos acessar os instantes de tempo via <code>sol.t</code>, os valores ao longo do tempo via <code>sol.u</code> e exibir a evolução da solução <code>u&#40;t&#41;</code> diretamente via <code>plot&#40;sol&#41;</code>. Podemos passar diversos argumentos da função <code>plot</code> para construir o gráfico.</p>
<p>Mais detalhes sobre a inferface podem ser vistos na página <a href="https://docs.sciml.ai/dev/modules/DiffEqDocs/types/rode_types/">RODE Problems</a>.</p>
<p>Agora, na prática, queremos inferir a evolução do processo como um todo, não apenas de um caminho amostral. Para isso, podemos usar o método de Monte-Carlo e inferir as estatísticas do processo estocástico através de um conjunto de caminhos amostrais. Podemos fazer isso resolvendo uma série de problemas de valor inicial como acima. Para facilitar esse processo e, inclusive, a análise do conjunto de soluções, os pacotes do SciML disponibilizam um <code>EnsembleProblem&#40;&#41;</code>, a ser montado a partir de um problema de valor inicial, como o <code>RODEProblem&#40;&#41;</code>. Em seguida, podemos acessar um resumo do resultado do conjunto de simulações através de <code>EnsembleSummary&#40;&#41;</code>. Mais informações na página <a href="https://diffeq.sciml.ai/stable/features/ensemble/">Parallel Ensemble Simulations</a>.</p>
<h3 id="resolvendo_uma_equação_aleatória_simples"><a href="#resolvendo_uma_equação_aleatória_simples" class="header-anchor">Resolvendo uma equação aleatória simples</a></h3>
<p>Por exemplo, vamos considerar o problema concreto</p>
\[
\frac{\mathrm{d}u}{\mathrm{d}t} = \sin(W) u, \quad t_0 \leq t \leq T,
\]
<p>com uma condição inicial</p>
\[
u(t_0) = x_0.
\]
<p>Nesse caso, podemos definir a função da seguinte forma</p>
<pre><code class="language-julia">f&#40;u, p, t, W&#41; &#61; sin&#40;W&#41; * u</code></pre>
<p>Para geramos o problema de valor inicial, escolhemos os parâmetros \(x_0 = 1\), \(t_0 = 0\) e \(T = 5\) e definimos</p>
<pre><code class="language-julia">u0 &#61; 1.0
tspan &#61; &#40;0.0, 5.0&#41;
prob &#61; RODEProblem&#40;f, u0, tspan&#41;</code></pre>
<p>Uma vez montado esse problema, podemos resolvê-lo via</p>
<pre><code class="language-julia">sol &#61; solve&#40;prob, RandomEM&#40;&#41;, dt&#61;1/100&#41;</code></pre>
<p>Após a simulação, podemos exibir o gráfico da solução via <code>solve</code>. Abaixo o código completo e o resultado da simulação.</p>
<pre><code class="language-julia">using StochasticDiffEq
using Plots
theme&#40;:ggplot2&#41;

f&#40;u, p, t, W&#41; &#61; sin&#40;W&#41; * u

u0 &#61; 1.0
tspan &#61; &#40;0.0, 5.0&#41;
prob &#61; RODEProblem&#40;f, u0, tspan&#41;

sol &#61; solve&#40;prob, RandomEM&#40;&#41;, dt&#61;1/100&#41;

plot&#40;sol, title &#61; &quot;solução da equação diferencial aleatória &#96;u&#39; &#61; sin&#40;W&#41;u&#96; com &#96;u&#40;0&#41; &#61; 1.0&#96;&quot;, titlefont &#61; 10, xaxis &#61; &quot;t&quot;, yaxis &#61; &quot;x&quot;, label &#61; false&#41;</code></pre>

<img src="/notas_sde/assets/pages/c09/sciml/code/output/rode_via_sciml.svg" alt="">
<h3 id="resolvendo_a_equação_logística_aleatória"><a href="#resolvendo_a_equação_logística_aleatória" class="header-anchor">Resolvendo a equação logística aleatória</a></h3>
<p>Vejamos, agora, como implementar a equação logística aleatória discutida anteriormente. A equação tem a forma</p>
\[
\frac{\mathrm{d}X_t}{\mathrm{d}t} = (A_t - B_t X_t)X_t,
\]
<p>onde</p>
\[
A_t = a + \delta Y_t, \qquad B_t = b + \varepsilon Z_t,
\]
<p>com</p>
\[
a, b, \delta, \varepsilon > 0, \quad a - \delta > 0, \quad b - \varepsilon > 0,
\]
<p>e onde</p>
\[
Y_t = \frac{W_t}{1 + |W_t|}, \quad Z_t = \sin(W_t).
\]
<p>Assim, podemos definir a função <code>f&#40;t, u, p, W&#41;</code> como</p>
<pre><code class="language-julia">function f&#40;u, p, t, W&#41;
    a, b, δ, ε &#61; p
    Y &#61; W / &#40;1 &#43; abs&#40;W&#41;&#41;
    Z &#61; sin&#40;W&#41;
    A &#61; a &#43; δ * Y
    B &#61; b &#43; ε * Z
    du &#61; &#40;A - B * u&#41; * u
    return du
end</code></pre>
<p>Observe que poderíamos ter escrito diretamente</p>
<pre><code class="language-julia">f&#40;u, p, t, W&#41; &#61; &#40;p&#91;1&#93; &#43; p&#91;3&#93; * W / &#40;1 &#43; abs&#40;W&#41;&#41; - &#40;p&#91;2&#93; &#43; p&#91;3&#93; * sin&#40;W&#41;&#41; * u&#41; * u</code></pre>
<p>mas, nesse caso, não há custo computacional algum em se introduzir as variáveis auxiliares e deixar o código mais claro. Isso pode ser verificado através da função de introspecção <code>@code_typed</code> &#40;leia mais sobre isso em <a href="https://docs.julialang.org/en/v1/devdocs/reflection/#Intermediate-and-compiled-representations">Intermediate and compiled representations</a>&#41;, que exibe o mesmo conjunto de instruções para ambas as definições &#40;verifique isso, por exemplo, através de <code>@code_typed f&#40;1.0, &#40;1.0, 2.0, 3.0, 4.0&#41;, 5.0, 6.0&#41;</code> em ambas as formas da função <code>f</code>&#41;. Ou seja, as sintaxes adicionadas por nós para facilitar a leitura da função são otimizadas e descartadas pelo compilador.</p>
<p>O restante do código é essencialmente o mesmo diante, exceto que, agora, precisamos definir o conjunto <code>p</code> de parâmetros. Isso é feito no código completo, a seguir.</p>
<pre><code class="language-julia">using StochasticDiffEq
using Plots
theme&#40;:ggplot2&#41;

function f&#40;u, p, t, W&#41;
    a, b, δ, ε &#61; p
    Y &#61; W / &#40;1 &#43; abs&#40;W&#41;&#41;
    Z &#61; sin&#40;W&#41;
    A &#61; a &#43; δ * Y
    B &#61; b &#43; ε * Z
    du &#61; &#40;A - B * u&#41; * u
    return du
end

u0 &#61; 1.0
p &#61; &#40;3.0, 2.0, 0.1, 0.2&#41;
tspan &#61; &#40;0.0, 5.0&#41;
prob &#61; RODEProblem&#40;f, u0, tspan, p&#41;

sol &#61; solve&#40;prob, RandomEM&#40;&#41;, dt&#61;1/100&#41;

plot&#40;sol&#41;</code></pre>

<img src="/notas_sde/assets/pages/c09/sciml/code/output/rode_via_sciml_pop.svg" alt="">
<p>Agora, na prática, queremos inferir a evolução do processo estocástico. Essa análise é facilitada pela função <code>EnsembleProblem&#40;&#41;</code>. Isso é ilustrado a seguir.</p>
<pre><code class="language-julia">using StochasticDiffEq
using Plots
theme&#40;:ggplot2&#41;

function f&#40;u, p, t, W&#41;
    a, b, δ, ε &#61; p
    Y &#61; W / &#40;1 &#43; abs&#40;W&#41;&#41;
    Z &#61; sin&#40;W&#41;
    A &#61; a &#43; δ * Y
    B &#61; b &#43; ε * Z
    du &#61; &#40;A - B * u&#41; * u
    return du
end

u0 &#61; 0.01
p &#61; &#40;3.0, 2.0, 0.1, 0.2&#41;
tspan &#61; &#40;0.0, 8.0&#41;
prob &#61; RODEProblem&#40;f, u0, tspan, p&#41;

ensembleprob &#61; EnsembleProblem&#40;prob&#41;
sol &#61; solve&#40;ensembleprob, RandomEM&#40;&#41;, EnsembleThreads&#40;&#41;, trajectories&#61;100, dt&#61;1/100&#41;
plot&#40;title &#61; &quot;conjunto de caminhos amostrais e um caminho em destaque&quot;, titlefont &#61; 12, xaxis &#61; &quot;t&quot;, yaxis &#61; &quot;população&quot;&#41;
plot&#33;&#40;sol, color &#61; 1, alpha &#61; 0.1&#41;
plot&#33;&#40;sol&#91;1&#93;&#41;

sol &#61; solve&#40;ensembleprob, RandomEM&#40;&#41;, EnsembleThreads&#40;&#41;, trajectories&#61;1000, dt&#61;1/100&#41;

summ95 &#61; EnsembleSummary&#40;sol&#41;
summ50 &#61; EnsembleSummary&#40;sol; quantiles&#61;&#91;0.25,0.75&#93;&#41;
plot&#40;title &#61; &quot;valor esperado e intervalos de amostras&quot;, titlefont &#61; 12, xaxis &#61; &quot;t&quot;, yaxis &#61; &quot;população&quot;&#41;
plot&#33;&#40;summ95, label &#61; &quot;95&#37; das amostras&quot;&#41;
plot&#33;&#40;summ50, label &#61; &quot;50&#37; das amostras&quot;&#41;</code></pre>

<img src="/notas_sde/assets/pages/c09/sciml/code/output/rode_via_sciml_pop_ensemb_trajectories.svg" alt="">
<img src="/notas_sde/assets/pages/c09/sciml/code/output/rode_via_sciml_pop_ensemb.svg" alt="">
<h2 id="resolvendo_equações_estocásticas_via_sciml"><a href="#resolvendo_equações_estocásticas_via_sciml" class="header-anchor">Resolvendo equações estocásticas via SciML</a></h2>
<p><a href="https://diffeq.sciml.ai/stable/types/sde_types/">A interface para a resolução de equações estocásticas</a> também é acessível pelo pacote <a href="https://github.com/SciML/StochasticDiffEq.jl">SciML/StochasticDiffEq.jl</a>. Nesse caso, precisamos informar a função de <em>drift</em> <code>f&#40;u, p, t&#41;</code> e a função de difusão <code>g&#40;u, p, t&#41;</code>. Veja os exemplos no <a href="https://diffeq.sciml.ai/stable/tutorials/sde_example/">tutorial de SDE</a>. Há uma <a href="https://diffeq.sciml.ai/stable/solvers/sde_solve/">série de métodos disponíveis para equações estocásticas</a>. O Euler-Maruyama para equações estocásticas é definido simplesmente por <code>EM&#40;&#41;</code>. Da mesma forma, podemos usar o método de Monte Carlo através do <code>EnsembleProblem&#40;&#41;</code>, conforme descrito em <a href="https://diffeq.sciml.ai/stable/features/ensemble/">Parallel Ensemble Simulations</a>.</p>

    <div class="navbar">
    <p id="nav">
<span id="nav-prev" style="float: left;">
<a class="menu-level-1" href="/notas_sde/pages/c09/simulacoes_milstein">9.7. Simulações Milstein <kbd>←</kbd></a>
</span>
<span id="nav-next" style="float: right;">
    <a class="menu-level-1" href="/notas_sde/pages/c10/deterministic"><kbd>→</kbd> 10.1. Evolução no caso de equações determinísticas</a>
</span>
    </p>
</div>
</br></br>



<div class="page-foot">
    
        <div class="license">
            <a href=https://creativecommons.org/licenses/by-nc-nd/4.0/>(CC BY-NC-ND 4.0) Attribution-NonCommercial-NoDerivatives 4.0 International </a>
            Ricardo M. S. Rosa
        </div>
    

    Last modified: July 25, 2022. Built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>, using the <a href="https://github.com/rmsrosa/booksjl-franklin-template">Book Template</a>.
</div><!-- CONTENT ENDS HERE -->

      </div> <!-- .books-content -->
    </div> <!-- .books-container -->

    
        <script src="/notas_sde/libs/katex/katex.min.js"></script>
        <script src="/notas_sde/libs/katex/auto-render.min.js"></script>
        <script>renderMathInElement(document.body)</script>
    

    
        <script src="/notas_sde/libs/highlight/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>
    

  </body>
</html>
